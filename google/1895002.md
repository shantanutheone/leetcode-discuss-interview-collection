# Google L3/L4 Interview Questions – Bangalore, India

Original Post – [https://leetcode.com/discuss/post/1895002/google-l3-l4-by-anonymous_user-6qhn/](https://leetcode.com/discuss/post/1895002/google-l3-l4-by-anonymous_user-6qhn/)

---

## Problem 1: Time Conversion and Optimization

### Description
You are given a list of time entries in 12-hour AM/PM format. Your task is to first convert these times into **minutes past midnight** (i.e., 0 to 1439 range). Then, apply a **greedy** or **dynamic programming (DP)** based algorithm to select a subset of these times based on new constraints to **maximize/minimize** a certain objective (e.g., total count, gap, etc.).

> This problem evolves from string parsing to greedy and finally into a DP formulation like **coin change**, depending on added constraints.

### Input
- A list of strings `times` representing times in 12-hour format (e.g., `"02:15PM"`, `"11:45AM"`).
- Constraints that may vary (e.g., allowed time gaps, max slots to choose, etc.).

### Output
- Varies based on constraints; could be a maximum count of time slots, minimum time gap, etc.

### Constraints
- 1 ≤ len(times) ≤ 10^4
- Format is guaranteed to be valid 12-hour AM/PM strings

### Example
```
Input: ["12:00AM", "01:15PM", "11:30PM"]
Parsed as: [0, 795, 1410]

(Behavior depends on specific constraints, such as selecting non-overlapping or maximally spaced times.)
```

---

## Problem 2: Maximum Value Triangle of Islands

### Description
You are given `n` islands, each with an associated integer value. Some islands are directly connected to each other (undirected edges). Select **3 distinct islands A, B, C** such that:

- A is directly connected to B  
- B is directly connected to C  
- A is directly connected to C  
(i.e., they form a **triangle**)

Return the **maximum total value** of any such valid triangle.

### Input
- An integer `n`, number of islands.
- An array `values` of size `n` where `values[i]` is the value of the i-th island.
- A list of connections (edges), each a tuple `(u, v)` representing a bidirectional connection.

### Output
- An integer representing the maximum total value of any valid triangle of islands.

### Constraints
- 3 ≤ n ≤ 10^5
- Each island has at most 100 connections.
- values[i] ∈ [-10^4, 10^4]

### Example
```
Input:
values = [5, 10, 15, 7]
edges = [(0,1), (1,2), (0,2), (0,3)]

Output:
30
```
Explanation: Triangle between islands 0, 1, 2: total = 5 + 10 + 15 = 30

---

## Problem 3: Social Media Friend Recommendation System

### Description
Design a **User Model** for a social media platform. Each user has basic profile attributes and a list of friends.

You are then required to build a **friend recommendation system** that suggests users to connect with based on mutual friends or interaction frequency.

### Input
- A set of users with their attributes and friendships.
- Optional interaction weights or mutual connections.

### Output
- A ranked list of friend recommendations for each user.

### Constraints
- System should scale to millions of users.
- Must support fast retrieval and updates.

### Example
```
User A → Friends: [B, C]
User B → Friends: [A, D]
→ Recommend D to A (mutual connection through B)
```

---

## Problem 4: Multi-Type Adjacency Graph Traversal

### Description
You are given a graph where each node may have multiple **types of connections**, represented as an adjacency map.

Instead of a normal adjacency list like:
```
adj[1] = [2, 5, 6]
```
you have:

```
adj[1] = {
"type1": [2],
"type2": [5,6],
"type3": []
}
```

Your task is to implement a **generic graph traversal** algorithm that can:
- Traverse through specific connection types.
- Support queries like "Find all nodes reachable from node `x` through only `type1` and `type2`".

### Input
- A graph `adj` where each node maps to a dict of types to neighbor lists.
- A starting node and list of allowed types.

### Output
- A list of nodes reachable under the constraints.

### Constraints
- Up to 10^5 nodes
- Each node can have up to 10 connection types

### Example

```
Input:
adj[1] = {
"type1": [2],
"type2": [3],
"type3": []
}
Start: 1
Allowed Types: ["type1", "type2"]

Output: [2, 3]
```